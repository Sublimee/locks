# locks branch

Блокировки БД
Создаем таблицу card (id: UUID, balance: NUMBER), добавить несколько записей (подготовить скрипт создания и заполнения через hibernate)

Пессимистичные блокировки (пробуем или через jdbc или hibernate)
Воспроизводим ситуацию блокировки ожидания: один поток делает SELECT FOR UPDATE строки, Thread.sleep, потом коммит, второй поток пытается обновить строку через UPDATE в момент, когда первый спит, второй поток ждет завершения блокировки первого потока.
Воспроизводим ситуацию блокировки ошибки: один поток делает SELECT FOR UPDATE строки, таймаут, потом коммит, второй поток пытается обновить строку SELECT FOR UPDATE NOWAIT  и вылетает по ошибке.

Оптимистические блокировки (hibernate, @Version)
Первый поток читает данные, вложенная транзакция обновляет ту же запись, первый поток делает изменения после вложенной транзакции. Смотрим что получилось.

# cache branch
Кэширование
Интегрируем кэш, позволяющий задать время жизни данных в кэше
Делаем controller c @Cacheble методом поиска карты по UUID. 
Делаем метод очистки кэша

# producer-consumer branch
Скалирование 
Делаем заполнение таблицы card 1 млн записей. Producer формирует DTO (с балансом) и кладет объект в блокирующую очередь. Consumer-ы, их кол-во определятся пропертей в yml файле, разбирают данные и кладут их в БД. Меняем кол-во consumer-ов, смотрим за производительностью.
